// Circle 클래스를 C++ 클래스를 이용하여 재작성
#include <iostream>
using namespace std;

// 구조체 선언
struct StructCircle
{
private:
    int radius;

public:
    // 구조체의 생성자
    StructCircle(int r) { radius = r; }
    double getArea();
};

double StructCircle::getArea()
{
    return 3.14 * radius * radius;
}

int main()
{
    StructCircle waffle(3);
    cout << "면적은 " << waffle.getArea();
}

/*
면적은 28.26

- 함수 호출에 따른 시간 오버헤드
시간을 무시할 수 없는 비중을 차지하는 경우가 있다
짧은 코드로 함수를 만들면, 함수 호출의 오버헤드가 상대적으로 커서 프로그램 실행 시간이 길어지는 ㅝㄴ인이 된다

- 인라인 함수
짧은 코드로 구성도니 함수에 대해, 함수 호출 오버헤드로 인한 프로그램의 실행 속도 저하를 막기 위해 도입된 기능
함수 앞에 inline 키워드를 이용한다
컴파일러는 인라인 함수를 호출하는 곳에 인라인 함수의 코드를 그대로 삽입하여 함수 호출이 일어나지 않게 한다
멤버 변수의 값을 알아내고 멤버 변수에 값을 쓰는 이른바 getter/setter 라는 작은 멤버 함수들이 많이 존재한다
인라인 함수를 호출하는 곳에 인라인 함수의 코드를 단순 삽입하므로  호출하는 곳이 여러 군데 있으면 그만큼 전체 크기가 늘어나는 단점

- 멤버 함수의 인라인 선언과 자동 인라인
생성자를 포함하여 클래스의 모든 멤버 함수가 인라인으로 선언될 수 있다
멤버 함수의 크기가 작은 경우, 클래스의 선언부에 직접 구현하여도 무방하다
컴파일러는 클래스의 선언부에 구현된 멤버 함수들에 대해서 inline 선언이 없어도 인라인 함수로 자동 처리한다

- C++ 구조체
구조체 STRUCT 를 지원한다
클래스와 동일한 구조와 기능을 가진다
struct 키워드를 선언하며, 멤버 변수와 멤버 함수를 가지고, 접근 지정도 해야 한다

- C++ 구조체의 객체 생성
구조체 타입 뒤에 객체 이름을 지정하면 된다
객체 새엇ㅇ 시 struct 키워드는 사용하지 않는다

- 구조체와 클래스의 차이점
멤버 변수뿐만 아니라 생성자와 소멸자 비롯한 멤버 함수를 가질 수 있다
다른 구조체나 클래스에게 상속 가능하고 다른 구조체나 클래스를 상속받을 수 있다
멤버들은 접근 지정자로 지정되며 멤버 활용도 클래스와 동일하다
클래스의 디폴트 접근 지정이 private 반면 구조체는 public 이다
*/